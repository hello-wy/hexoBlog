title: 文件上传
author: 远方
tags:
  - LeetCode
  - 算法
categories:
  - LeetCode破局攻略
date: 2016-01-01 19:20:00
---
[Toc]



# 基本思路

用户请求上传文件，服务器处理这个请求，并且返回一个签名给到用户，用户通过这个签名来访问，文件存储系统，进行上传文件。文件存储系统的账号密码都是保存在自己服务器中的，比较的安全。

![](https://s2.loli.net/2022/06/20/mDvuMC3e7iBynNj.png)



# 实现

minio使用指南

使用一个新的maven项目来存放所有的第三方包。

## 加入到父项目项目中（聚合）

## 添加依赖包

### 还需要加入common，

### minio注意

这里使用的是minio的依赖包，这里注意版本号的问题，需要排除okhttp版本

```xml
        <dependency>
            <groupId>io.minio</groupId>
            <artifactId>minio</artifactId>
            <version>8.4.2</version>
            <exclusions>
                <exclusion>
                    <groupId>com.squareup.okhttp3</groupId>
                    <artifactId>okhttp</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>me.tongfei</groupId>
            <artifactId>progressbar</artifactId>
            <version>0.5.3</version>
        </dependency>

        <dependency>
            <groupId>com.squareup.okhttp3</groupId>
            <artifactId>okhttp</artifactId>
            <version>4.8.1</version>
        </dependency>
```



## 注册到nacos中，并且配置配置中心等信息

加入到minio中的配置信息

```yml
#minio配置
minio:
  access-key: admin      #key就是docker初始化是设置的，密钥相同
  secret-key: admin123456
  url: http://120.55.125.132:9000
  bucket: gmall
  min: 10*1024    #10kb
  max: 10*1024*1024   #10MB
```



## 使用一个配置类获取配置

```java
@Configuration
@Data
public class MinioConfiguration {
    @Value("${minio.access-key}")
    private String accessKey;
    @Value("${minio.secret-key}")
    private String secretKey;
    @Value("${minio.url}")
    private String url;
    @Value("${minio.bucket}")
    private String bucketName;

    @Bean
    public MinioClient minioClient() {
        return MinioClient.builder()
                .endpoint(url)
                .credentials(accessKey, secretKey)
                .build();
    }
}
```



## 业务逻辑方面

### service服务

```java
@Component
@Slf4j
public class MinioClientPolicy {
    @Autowired
    private MinioConfiguration minioConfiguration;

    @Autowired
    private MinioClient minioClient;

    @Value("${minio.min}")
    private String min;

    @Value("${minio.max}")
    private String max;

    /**
     * 用户获得上传签名
     *
     * @param fileName 上传文件
     * @param time     过期时间,指定
     * @return
     */
    public Map getPolicy(String fileName, ZonedDateTime time) {
//        给储存桶创建一个上传策略,过期时间是time
        PostPolicy postPolicy = new PostPolicy(minioConfiguration.getBucketName(), time);

//        设置一个参数key,值为上传对象的名称
        postPolicy.addEqualsCondition("key", fileName);
//        设置content-type,表示只能上传图片
        postPolicy.addStartsWithCondition("Content-type", "image/");
//        postPolicy.addContentLengthRangeCondition(Integer.valueOf(min), Integer.valueOf(max));
        Map<String, String> map = null;
        try {
//            获得对象上传的策略,包括签名,文件信息,路径,
            map = minioClient.getPresignedPostFormData(postPolicy);
            map.put("host", minioConfiguration.getUrl() + "/" + minioConfiguration.getBucketName());
            return map;
        } catch (Exception e) {
            log.error("请求文件上传策略失败!错误原因:[{}]", e.getMessage());
        }
        return null;
    }

    /**
     * 获取上传文件的url
     * @param objectName
     * @param method
     * @param time
     * @param timeUnit
     * @return
     */
    public String getPolicyUrl(String objectName, Method method, int time, TimeUnit timeUnit) {
        try {
            return minioClient.getPresignedObjectUrl(GetPresignedObjectUrlArgs.builder()
                    .method(method)
                    .bucket(minioConfiguration.getBucketName())
                    .object(objectName)
                    .expiry(time, timeUnit).build());
        } catch (Exception e) {
            log.info("获取上传url失败!");
        }
        return null;
    }

    /**
     * 通过文件名称获取url
     * @param objectName
     * @param time
     * @param timeUnit
     * @return
     */
    public String getUrl(String objectName, int time, TimeUnit timeUnit) {
        String url = null;
        try {
            url = minioClient.getPresignedObjectUrl(GetPresignedObjectUrlArgs.builder()
                    .method(Method.GET)
                    .bucket(minioConfiguration.getBucketName())
                    .object(objectName)
                    .expiry(time, timeUnit).build());
        } catch (Exception e) {
            log.error("根据文件名称获取文件url失败!,失败原因:[{}]",e.getMessage());
        }
        return url;
    }
}
```



### controller

```java
@RestController
@RequestMapping("third-party/")
public class OssController {

    @Autowired
    private MinioClientPolicy minioClientPolicy;
    
    /**
     * 获得上传的url地址
     * @param fileName
     * @return
     */
    @GetMapping("/uploadUrl")
    public R uploadUrl(@RequestParam("fileName") String fileName) {
        String url = minioClientPolicy.getPolicyUrl(fileName, Method.PUT, 2, TimeUnit.MINUTES);
        return R.ok().put("data",url);
    }
}

```



一个方法是获取上传策略，作用是获取令牌，

另一个是获取上传url路径，有了令牌就需要，用户通过浏览器自己上传文件而不是服务器进行上传。

最后返回的url地址，可以通过put请求进行上传文件。

# 前后端联调

## 后端业务

### 注意事项:

> 需要使用put请求,官方要求,get请求是获得文件的访问地址,post请求会报错.

## 前端业务

### 技术

前端采取的是elementui 的el-upload组件,以及vue

### 实现

```html
<el-upload
      action="https://jsonplder.typiposts/"		#这里随便填写,我们不使用这个默认的上传方式
      list-type="picture"		
      :multiple="false"			
      :show-file-list="showFileList"
      :file-list="fileList"		可以进行回显的文件列表
      :http-request="upload"		#在这里就是定义使用自己的上传方法.upload
      :before-upload="beforeUpload"
      :on-remove="handleRemove"
      :on-success="handleUploadSuccess"
      :on-preview="handlePreview"
    >
      <el-button size="small" type="primary">点击上传</el-button>
      <div slot="tip" class="el-upload__tip">
        只能上传jpg/png文件，且不超过10MB
      </div>
    </el-upload>
```



```js
/**
 * 文件上传之前的操作,在这前后端进行交互,获得minio的签名,后端会返回给前端,前端进行保存
 * @param {*} file 
 */
beforeUpload(file) {
      let _self = this;
      console.log(file);
      let ext = file.name.substring(file.name.lastIndexOf(".") + 1);
      console.log(ext);
      let filename = getUUID() + "." + ext;
      this.fileName = filename;
      return new Promise((resolve, reject) => {
        http({
          url: http.adornUrl("/thirdparty/uploadUrl"),
          method: "get",
          params: { fileName: filename }
        })
          .then(response => {
            _self.minioUrl = response.data.data;
            console.log(this.minioUrl);
            resolve(true);
          })
          .catch(err => {
            reject(false);
          });
      });
},
/**
 * 重写了文件上传,在这里上传文件,通过后端返回给我们的url地址.使用put进行上传.
 * @param {*} res 
 * @param {*} file 
 */
    upload(file) {
      let binFile = file.file;
      return new Promise((resolve, reject) => {
        http({
          url:this.minioUrl,
          method: "put",
          data:{
            file:binFile
          }
        }).then(res=>{
        console.log("文件上传成功");
          resolve(true)
        }).catch(error=>{
          console.log("文件上传失败");
          reject(false)
        })
      });
    },
```



### 总结

三个步骤，

1. 获得令牌，上传文件
2. 通过令牌获取上传的url。
3. 用户通过返回的url进行上传文件



# 网关配置

和前面差不多，基本上一致。





# 遇到的问题

## @value获得不到数据

版本原因，需要降低版本，springcloud版本和主项目一致。





## jar包冲突

![](https://s2.loli.net/2022/06/20/A397lFm5uYedDKG.png)

### **原因：**

根据上面的异常信息分析，可能是okhttp依赖冲突造成的服务启动失败，因为minio底层要依赖okhttp进行和minio服务端进行通信，由于项目中多个依赖底层都依赖了不同版本的okhttp，导致这里的okhttp因版本不同，某些方法不可用，尝试降级minio的版本，如下：最好排除掉版本中原来的okhttp。

### 解决方法

```xml
        <dependency>
            <groupId>io.minio</groupId>
            <artifactId>minio</artifactId>
            <version>8.4.2</version>
            <exclusions>
                <exclusion>
                    <groupId>com.squareup.okhttp3</groupId>
                    <artifactId>okhttp</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>me.tongfei</groupId>
            <artifactId>progressbar</artifactId>
            <version>0.5.3</version>
        </dependency>

        <dependency>
            <groupId>com.squareup.okhttp3</groupId>
            <artifactId>okhttp</artifactId>
            <version>4.8.1</version>
        </dependency>
```

## 前端上传不了数据一直报错

### 情况:

可以通过postman上传文件,但是就是不可以使用vue+element上传。

### 解决：重写默认的upload方法解决，使用put请求

一开始使用的是别人封装好的包进行请求地址。也就是把file二进制文件放到了params进行put请求，最后还是分析postman和前端上传的不同发现的。以后遇到这样的问题一定要进行比较发现问题（postman、vue）。



```js
return new Promise((resolve, reject) => {
        http({
          url:this.minioUrl,
          method: "put",
          data:{
            file:binFile			有问题不能使用data进行传参，这样会出现文件格式不正确的情况，需要使用binary格式上传		使用date: binFile
          }
        }).then(res=>{
        console.log("文件上传成功");
          resolve(true)
        }).catch(error=>{
          console.log("文件上传失败");
          reject(false)
        })
      });
```



## 文件无法预览

结局上传问题之后，还没有完全完成，现在的问题就是上传没有问题但是就是没有办法下载预览，也就是文件提示格式是错误的。

### 解决：

这个问题出现的原因是我使用的是data进行上传对象，这样写的是一个对象到文件中并不是一个二进制文件，这个文件包含了一些头信息之类的。

只需要把上传的文件改成一个二进制文件,之前是一个对象

**前后对比**

```js
data: binFile		后
data:{file:binFile}		前
```



