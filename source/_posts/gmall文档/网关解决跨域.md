title: 网关解决跨域
author: 远方
tags:
  - LeetCode
  - 算法
categories:
  - LeetCode破局攻略
date: 2016-01-01 19:20:00
---
# 最开始没有使用网关进行转发

最开始时候前端都是使用对应服务的绝对地址进行访问的。

## 开始改造

vue的baseurl改成网关地址，并且添加/api，这个/api为了网关好进行判断这个是请求，进行跨域访问。

一般baseurl在main.js中

```js
baseUrl="http://192.168.1.106:10616/api";		//这个192.168.1.106:10616是网关地址
//后面具体的接口还会拼接一些接口
```

这样前端请求的地址都变成了网关的地址，网关需要进行处理转发。既然你需要网关发送，那么服务一定要在nacos中注册。

## 服务注册

1、如果服务没有注册，需要注册到nacos中（不需要使用namespace），并且添加配置中心（这里最好添加上namespace）。

```yml
# Spring
spring:
  application:
    # 应用名称
    name: gmall-gateway
  cloud:
    nacos:
      discovery:
        # 服务注册地址
        server-addr: 127.0.0.1:8848
      config:
        # 配置中心地址
        server-addr: 127.0.0.1:8848
        namespace: c991b9c0-b4d0-4057-b5fa-29450a81d75b
```



2、配置完成不要忘了在启动类添加一个注解`@EnableDiscoveryClient`。

## 配置网关路由

1. 现在配置的只是服务的注册以及配置，需要网关发挥路由的作用还需要进行路由配置。
2. 并且配置的访问地址是携带api的，在真实的请求中我们是不需要`api`这个字段的。



针对上述问题，解决方法是在application.yml文件中配置如下：（配置路由需要注意的是）

> 注意这个文件已经将配置了两个路径，精确的路由放到上面，gateway是自上往下执行匹配的。

```yml
spring:
  cloud:
    gateway:
      routes:
#          精确的路由放上面
        - id: product_route
          uri: lb://gmall-product		#lb是进行负载均衡
          predicates:		#路由匹配规则只有符合要求的才可以使用这个规则
            - Path=/api/product/**		
          filters:		#解决上述2问题，路由配置问题，需要对路由进行重写
            - RewritePath=/api/(?<segment>.*),/$\{segment}

        - id: admin_route
          uri: lb://renren-fast
          predicates:
            - Path=/api/**
          filters:
            - RewritePath=/api/(?<segment>.*),/renren-fast/$\{segment}
```

### `RewritePath=/api/(?<segment>.*),/$\{segment}`

`(?<segment>.*)`：表示将后面`.*`匹配到的内容捕获到segment中，相当于替换

`$\{segment}`：分组捕获进行替换

之所以使用`\`是因为避免yaml语法认为这是一个变量，`${name}`这个就是一个变量.



### 总结

`predicates` 进行==拦截==

`filters` ： 进行==路径重写==等操作



常常会遇到跨站访问（跨域）的问题。

可以通过nginx来解决，还可以通过网关来解决。配置好路由规则就可以跳转相应的地址。



# 跨域问题解决

正常的情况这个时候访问接口，应该是没有问题的。但是访问接口的时候发生了跨域问题。

**原因**：cors头缺少‘access-control-allow-origin’

1. 解决方法一：通过nginx来解决
2. 解决二，服务器请求允许跨域请求（添加headers，methods·····）



## 后端添加过滤器允许跨站访问

```java
@Configuration
public class myCorsConfigration {

    //使用corswebfilter来做跨域,这个是一个接口,所以,找到一个具体的实现类(UrlBasedCorsConfigurationSource)
    @Bean
    public CorsWebFilter corsWebFilter(){
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        //创建跨域配置
        CorsConfiguration corsConfiguration = new CorsConfiguration();

        corsConfiguration.addAllowedHeader("*");
        corsConfiguration.addAllowedMethod("*");    //请求方式
        corsConfiguration.addAllowedOrigin("*");        //请求来源
        corsConfiguration.setAllowCredentials(true);
//        所有路径都需要跨域，这个注册需要配置，创建配置添加允许跨域请求头
        source.registerCorsConfiguration("/**",corsConfiguration);
        return new CorsWebFilter(source);
    }

}
```

> 注意这些cors包引入的都是reactive包下的，spring是响应式的。



# 问题注意

## 网关转发需要在一个命名空间下（public）

在服务注册的时候，不要分命名空间，命名空间只是在配置中心的时候在使用到的。

## 出现了多个跨域请求

也就是一个项目中配置了两次跨站允许请求头，解决去掉一处的配置。
